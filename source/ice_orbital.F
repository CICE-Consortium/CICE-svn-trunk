! CVS: $Name$
!=======================================================================
!BOP
!
! !MODULE: ice_orbital - computes orbital parameters for solar zenith angle
!
! !DESCRIPTION:
!
! Orbital parameters computed from date
!
! !REVISION HISTORY:
!
! author:  Bruce P. Briegleb, NCAR 
!
! !INTERFACE:
!
      module ice_orbital
!
! !USES:
!
      use ice_kinds_mod
      use ice_domain
      use ice_domain_size
      use ice_constants
      use shr_orb_mod
!
!EOP
!
      implicit none
      save

      integer (kind=int_kind) :: iyear_AD  ! Year to calculate orbit for
 
      real(kind=dbl_kind) :: eccen  !Earth's orbital eccentricity
      real(kind=dbl_kind) :: obliqr !Earth's obliquity in radians
      real(kind=dbl_kind) :: lambm0 !Mean longitude of perihelion at the
                                    !vernal equinox (radians)
      real(kind=dbl_kind) :: mvelpp !Earth's moving vernal equinox longitude
                                    !of perihelion + pi (radians)
      real(kind=dbl_kind) :: obliq  ! obliquity in degrees
      real(kind=dbl_kind) :: mvelp  ! moving vernal equinox long
      real(kind=dbl_kind) :: delta  ! solar declination angle in radians
      real(kind=dbl_kind) :: eccf   ! earth orbit eccentricity factor

      logical(kind=log_kind) :: log_print ! Flags print of status/error
 
!=======================================================================
 
      contains
 
!=======================================================================
!BOP
!
! !IROUTINE: init_orbit - initialize orbital parameters
!
! !INTERFACE:
!
      subroutine init_orbit
!
! !DESCRIPTION:
!
! Uses share routines to compute orbital parameters
! for the specified date.
!
! !REVISION HISTORY:
!
! author:  Bruce P. Briegleb, NCAR 
!
! !USES: none
!
! !INPUT/OUTPUT PARAMETERS: none
!
!EOP
!
      iyear_AD  = 1950
      log_print = .false.   ! if true, write out orbital parameters
!
      call shr_orb_params( iyear_AD , eccen  , obliq , mvelp     ,
     &                     obliqr   , lambm0 , mvelpp, log_print )
 
      end subroutine init_orbit
 
!=======================================================================
!BOP
!
! !IROUTINE: compute_coszen - computes cosine solar zenith angle
!
! !INTERFACE:
!
      subroutine compute_coszen (nx_block, ny_block,
     &                           icells,
     &                           indxi,    indxj,
     &                           tlat,     tlon,
     &                           coszen)
!
! !DESCRIPTION:
!
! Uses orbital and lat/lon info to compute cosine solar zenith angle
! for the specified date.
!
! author:  Bruce P. Briegleb, NCAR 
!
! !USES:
!
      use ice_calendar, only: yday, sec, secday
! 
! !INPUT/OUTPUT PARAMETERS: 
! 
      integer (kind=int_kind), intent(in) ::
     &   nx_block, ny_block  ! block dimensions
     &,  icells              ! number of ice-covered grid cells

      integer (kind=int_kind), dimension (nx_block*ny_block) ::
     &   indxi               ! indices for ice-covered cells
     &,  indxj
 
      real (kind=dbl_kind), dimension(nx_block,ny_block), intent(in) ::
     &   tlat, tlon          ! latitude and longitude (radians)

      real (kind=dbl_kind), dimension(nx_block,ny_block), intent(out) ::
     &   coszen              ! cosine solar zenith angle 
                             ! negative for sun below horizon
!
!EOP
!
      real (kind=dbl_kind) :: ydayp1 ! day of year plus one time step
 
      integer (kind=int_kind) ::
     &   i       ! domain longitude index
     &,  j       ! domain latitude index
     &,  ij      ! horizontal index, combines i and j loops
 
 
! Solar declination for next time step
 
      ydayp1 = yday + sec/secday
 
      call shr_orb_decl(ydayp1, eccen, mvelpp, lambm0, 
     &                  obliqr, delta, eccf)

      coszen(:,:) = c0  ! sun at horizon

cdir$ ivdep      !Cray
!cdir nodep      !NEC
!ocl novrec      !Fujitsu
      do ij = 1, icells
         i = indxi(ij)
         j = indxj(ij)
!lipscomb - function inlined to improve vector efficiency
!         coszen(i,j) = shr_orb_cosz(ydayp1,
!     &                              tlat(i,j),tlon(i,j),delta)

         coszen(i,j) = sin(tlat(i,j))*sin(delta) -
     &                 cos(tlat(i,j))*cos(delta)
     &                *cos(ydayp1*c2*pi + tlon(i,j))

      enddo
 
      end subroutine compute_coszen
 
!=======================================================================
 
      end module ice_orbital
 
!=======================================================================
